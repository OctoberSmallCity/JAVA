



     1.volatile-类型修饰符
	    用来修饰被不同线程访问的变量;
	    可见性:
	    (1)每次访问时,总是获取主内存的最新值;(保证了可见性,一个线程修改了变量,新值对其他变量是立即可见的);
		(2)禁止对指令重排序;
		
		原子性:
		     
			 没办法保证对变量操作的原子性;
			举例理解: 
			     首先自增操作包括:对变量的读取,进行+1操作,写入工作内存;
				 无法保证原子性意味着这三步操作可能被分隔开;
				 出现的情况:线程1对i进行自增操作,读取i的原始值,然后被阻塞了;
				            线程2对i进行自增操作,读取i的原始值,由于线程1没有对i进行修改操作,线程2中的缓存变量i的缓存行并没有失效;
							线程2会直接读取缓存值进行加1操作,并写入自己的工作内存,以及主内存;
							而后,线程1由于读取了,进行+1操作;并写入自己的工作内存以及主内存;
							两次后只加了1,而不是加2;
							
		有序性:
		     禁止对指令重排序一定程度上保证了有序性;
             
			 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
			 
			 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
                
	2.实现机制与原理
         
         “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<<深入理解JAVA虚拟机>>

         lock前缀正好实现了volatile的两个特性;		 
	
	
	3.为什么要有volatile
	     (1)内存模型
		     数据的读取与写入为了提高执行效率,不是与主内存进行交互的,而是通过cpu高速缓存进行的;
			 因此当多个线程操作时,会出现缓存不一致问题(多个线程对i操作,变量i在多个cpu中有缓存);
			 
			 解决缓存不一致问题:
			      
				 1)总线加Lock:阻塞其他CPU的访问,效率低;
				 
				 2)缓存一致协议:当一个CPU发现操作的变量是共享变量时,会通知其他CPU该变量的副本已经失效;
				                当其他CPU操作时会重新读取;
				
		 (2)并发中的三个特性
		     1)原子性
			 
			     一个操作或多个操作,要么全都执行并且不会被打断,要么全不执行;
				 
			 2)可见性
			 
			     一个线程修改了变量的值,其他线程可以看得到修改的值;
				 
			 3)有序性
			 
			     程序执行的顺序按照代码执行的先后顺序执行;
				 
				 但,JVM会进行指令重排序;
				 
				 指令重排不会影响单线程的执行,但会影响多线程的执行;
				 
		 (3)Java内存模型
		 
		     1)原子性
			    
				 对基本数据类型的变量的简单的读取与赋值是原子性操作;
				 
				 可用synchronized和lock实现原子性;
				 
			 2)可见性
			 
			     Java提供volatile关键字来保证可见性;
				 
				 也可用synchronized和lock实现,保证在同一时刻只有一个线程获取锁来实行同步代码,在释放锁之前更新值到内存;
				 
				 final关键字实现可见性:被final修饰的字段在构造器中一旦被初始化完成,并且构造器没有把"this"的引用传递过去
                (this引用逃逸非常危险),其他线程有可能通过这个引用访问到"初始化一半"的对象;				 
				 
			 3)有序性
			 
			     volatile可以保证有序性;
				 
				 synchronized和lock也可以实现,让线程同步执行代码;
				 
				 happens-before原则(先行发生原则)
			 
			     
			 
		
	 